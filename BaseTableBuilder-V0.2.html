
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Arweave JSON Template → Baby Address Table (fixed)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root {
    --bbn-bg: #030712;
    --bbn-surface: #060b1a;
    --bbn-surface-soft: #0b1024;
    --bbn-border: #1f2937;
    --bbn-accent: #cf6533;  /* Babylon orange-ish */ 
    --bbn-accent-soft: #e3a689;
    --bbn-text: #f9fafb;
    --bbn-text-muted: #9ca3af;
    --bbn-positive: #22c55e;
    --bbn-negative: #f97316;
  }

  body {
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    margin: 0;
    padding: 24px;
    background: radial-gradient(circle at top, #0b1120 0, #020617 55%, #000 100%);
    color: var(--bbn-text);
  }

  .container {
    max-width: 1180px;
    margin: 0 auto;
    background: linear-gradient(135deg, rgba(14, 116, 144, 0.18), rgba(207, 101, 51, 0.14));
    padding: 1px;
    border-radius: 18px;
    box-shadow:
      0 24px 60px rgba(0, 0, 0, 0.75),
      0 0 0 1px rgba(15, 23, 42, 0.9);
  }

  .container > * {
    background: radial-gradient(circle at top left, #0f172a 0, #020617 55%);
    border-radius: 18px;
    padding: 20px 22px 22px;
  }

  h1 {
    text-align: center;
    margin: 0 0 16px;
    font-size: 1.35rem;
    letter-spacing: 0.03em;
    color: var(--bbn-text);
  }

  .controls {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-bottom: 10px;
  }

  input[type="text"] {
    flex: 1;
    min-width: 260px;
    padding: 9px 11px;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.6);
    background: radial-gradient(circle at top left, #020617 0, #020617 40%, #020617 100%);
    color: var(--bbn-text);
    font-size: 0.92rem;
    outline: none;
    box-shadow: 0 0 0 1px transparent;
    transition: border-color 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
  }

  input[type="text"]::placeholder {
    color: var(--bbn-text-muted);
  }

  input[type="text"]:focus {
    border-color: var(--bbn-accent-soft);
    box-shadow: 0 0 0 1px rgba(227, 166, 137, 0.5);
    background: radial-gradient(circle at top left, #020617 0, #020617 40%, #020617 100%);
  }

  button {
    padding: 9px 16px;
    border-radius: 999px;
    border: none;
    background: radial-gradient(circle at top left, var(--bbn-accent) 0, #f97316 40%, #fb923c 100%);
    color: #0b0b0b;
    font-weight: 600;
    font-size: 0.9rem;
    letter-spacing: 0.03em;
    cursor: pointer;
    box-shadow:
      0 10px 25px rgba(248, 113, 113, 0.35),
      0 0 0 1px rgba(248, 250, 252, 0.05);
    transition: transform 0.12s ease, box-shadow 0.12s ease, filter 0.12s ease;
    white-space: nowrap;
  }

  button:hover:not(:disabled) {
    transform: translateY(-1px);
    filter: brightness(1.05);
    box-shadow:
      0 14px 30px rgba(248, 113, 113, 0.45),
      0 0 0 1px rgba(248, 250, 252, 0.1);
  }

  button:active:not(:disabled) {
    transform: translateY(0);
    box-shadow:
      0 6px 18px rgba(248, 113, 113, 0.3),
      0 0 0 1px rgba(248, 250, 252, 0.08);
  }

  button:disabled {
    opacity: 0.55;
    cursor: default;
    box-shadow: none;
  }

  .msg {
    margin: 6px 0 14px;
    color: var(--bbn-text-muted);
    white-space: pre-wrap;
    font-size: 0.9rem;
  }

  .table-shell {
    margin-top: 8px;
    border-radius: 16px;
    overflow: hidden;
    background: radial-gradient(circle at top left, #020617 0, #020617 40%, #020617 100%);
    box-shadow:
      0 18px 45px rgba(0, 0, 0, 0.8),
      0 0 0 1px rgba(15, 23, 42, 0.9);
    border: 1px solid rgba(15, 23, 42, 1);
  }

  .table-header-strip {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 14px;
    background: radial-gradient(circle at top left, #020617 0, #020617 40%, #020617 100%);
    border-bottom: 1px solid rgba(30, 64, 175, 0.7);
  }

  .table-header-strip .title {
    font-size: 0.95rem;
    font-weight: 600;
    color: #e5e7eb;
  }

  .table-header-strip .meta {
    font-size: 0.8rem;
    color: var(--bbn-text-muted);
  }

  table {
    width: 100%;
    border-collapse: collapse;
    background: transparent;
    font-size: 0.88rem;
  }

  th,
  td {
    padding: 8px 10px;
    text-align: left;
    vertical-align: middle;
    border-bottom: 1px solid rgba(31, 41, 55, 0.85);
  }

  th {
    position: sticky;
    top: 0;
    z-index: 2;
    background: linear-gradient(
      180deg,
      rgba(15, 23, 42, 0.98),
      rgba(15, 23, 42, 0.95)
    );
    font-size: 0.78rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: #9ca3af;
  }

 tbody tr:nth-child(odd) td {
  background: rgba(15, 23, 42, 0.9); /* dark row */
}

tbody tr:nth-child(even) td {
  background: rgba(207, 101, 51, 0.16); /* orange/red wash */
}

/* On hover, intensify the orange a bit */
tbody tr:hover td {
  background: radial-gradient(
    circle at left,
    rgba(207, 101, 51, 0.45),
    rgba(15, 23, 42, 0.95)
  );
}

  td:first-child {
    font-weight: 500;
    color: #e5e7eb;
    white-space: nowrap;
  }

  .amount {
    font-feature-settings: "tnum" 1, "lnum" 1;
  }

  .amount.positive {
    color: var(--bbn-positive);
  }

  .amount.negative {
    color: var(--bbn-negative);
  }

  .amount.net {
    color: #e5e7eb;
  }
</style>

</head>
<body>
  <div class="container">
    <h1 id="pageTitle">Arweave JSON Table Viewer</h1>

    <div class="controls">
      <input id="value" type="text"
             value="https://rt77saoki3w4zz4uo2ddkod5m6ljfudbvwjwhrpbrgp5qpszxyzq.arweave.net/jP_5AcpG7cznlHaGNTh9Z5aS0GGtk2PF4Ymf2D5ZvjM">
      <button id="loadBtn">Load & Build Table</button>
    </div>

    <div id="msg" class="msg"></div>
    <div id="tableWrapper"></div>
  </div>

<script>
/*
  Fixed behaviour:
  - Explicitly use template.SeverancePayAddress as the "subtraction" (negative) address.
  - Use template.address (or fallback to another key) as the addition (positive) address.
  - For templates with 3 value columns (like your JSON: ["label", "# At Shop", "# In Truck", "# Used Last"])
      - Column 1  => positive: amount received by `address`
      - Column 2  => negative: amount received by `SeverancePayAddress` (shown as negative)
      - Column 3  => net: (add - sub)
  - If columns differ, code will attempt reasonable mapping:
      - 2 value columns -> [add, negative sub]
      - 1 value column  -> [net only]
  - The example uses a mock fetchCosmosTxs (generates deterministic mock amounts). Replace fetchCosmosTxs with real RPC/lcd calls to fetch incoming tx amounts per address in production.
*/

const input = document.getElementById('value');
const btn = document.getElementById('loadBtn');
const msgEl = document.getElementById('msg');
const titleEl = document.getElementById('pageTitle');
const tableWrapper = document.getElementById('tableWrapper');

/**
 * Mock: returns 'needed' incoming amounts (in smallest unit, e.g., ubabylon = 1e6)
 * Deterministic seeded pseudo-random for demo so repeated loads produce same numbers for the same address.
 * Replace this with a proper Babylon RPC / LCD query that returns incoming transfers to an address.
 */
function seededAmountsFor(addr, needed) {
  const out = [];
  // very simple deterministic hash-ish number from addr
  let seed = 0;
  for (let i = 0; i < addr.length; i++) seed = ((seed << 5) - seed) + addr.charCodeAt(i);
  seed = Math.abs(seed) || 12345;
  for (let i = 0; i < needed; i++) {
    // produce values in range [10000, 3_000_000]
    seed = (seed * 9301 + 49297) % 233280;
    const v = 10000 + Math.floor((seed / 233280) * 2990000);
    out.push(v);
  }
  return out;
}

/**
 * fetchCosmosTxs - placeholder. Should return an array of 'needed' numeric amounts (in smallest denom).
 * In production, query Babylon/Cosmos LCD or RPC for transfers incoming to `address` and parse the amounts.
 */
async function fetchCosmosTxs(address, needed) {
  // Demo mock:
  await new Promise(r => setTimeout(r, 120)); // small simulated latency
  return seededAmountsFor(address, needed);
}

function clearTable(){ tableWrapper.innerHTML = ''; }

function isProbablyAddress(s) {
  return typeof s === 'string' && s.length > 10; // loose check; allow bbn*, babylon*, cosmos*, etc.
}

function formatToken(amountSmallest, divisor = 1e6) {
  const sign = amountSmallest < 0 ? '-' : '';
  const v = Math.abs(Number(amountSmallest)) / divisor;
  // round to nearest integer; no fractional part
  const rounded = Math.round(v);
  return sign + rounded.toLocaleString('en-US');
}

function buildTable(title, columnTitles, rowNames, dataMatrix, denomLabel) {
  clearTable();
  if (title) titleEl.textContent = title;

  const table = document.createElement('table');
  const thead = document.createElement('thead');
  const tbody = document.createElement('tbody');

  // header
  const headerRow = document.createElement('tr');
  const emptyTh = document.createElement('th'); emptyTh.textContent = ''; headerRow.appendChild(emptyTh);
  columnTitles.forEach(ct => { const th = document.createElement('th'); th.textContent = ct; headerRow.appendChild(th); });
  thead.appendChild(headerRow);

  rowNames.forEach((rowName, rIdx) => {
    const tr = document.createElement('tr');
    const first = document.createElement('td'); first.textContent = rowName; tr.appendChild(first);

    const rowData = dataMatrix[rIdx] || [];
    for (let c = 0; c < columnTitles.length - 1; c++) {
      const td = document.createElement('td');
      const val = rowData[c];
      if (val === null || val === undefined) td.textContent = '';
      else td.textContent = formatToken(val, denomLabel);
      tr.appendChild(td);
    }
    tbody.appendChild(tr);
  });

  table.appendChild(thead);
  table.appendChild(tbody);
  tableWrapper.appendChild(table);
}

async function loadAndBuild() {
  const url = input.value.trim();
  if (!url) { msgEl.textContent = 'Please enter an Arweave JSON URL (or data URL).'; return; }

  btn.disabled = true;
  msgEl.textContent = 'Fetching Arweave JSON template...';

  try {
    let res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP error ${res.status}`);
    const template = await res.json();

    const title = template.title || 'Untitled';
    const columns = template.columns || [];
    const rows = template.rows || [];
    const numRows = rows.length;
    if (numRows === 0) throw new Error('No rows defined in template.');
    const numValueCols = Math.max(1, columns.length - 1);

    // Prefer explicit keys if present
    let addrSub = template.SeverancePayAddress || null; // should be treated as subtraction (negative)
    let addrAdd = template.address || null; // positive

    // fallback: try last two keys in object insertion order if explicit keys not present
    if ((!addrSub || !addrAdd)) {
      const keys = Object.keys(template);
      // look for two last string-like values that look like addresses
      for (let i = keys.length - 1; i >= 0 && (!addrAdd || !addrSub); i--) {
        const k = keys[i];
        const v = template[k];
        if (!addrAdd && isProbablyAddress(v) && k.toLowerCase().includes('address')) {
          // prefer any key named like address
          if (k.toLowerCase().includes('severance')) addrSub = v;
          else addrAdd = addrAdd || v;
        } else if (isProbablyAddress(v)) {
          if (!addrAdd) addrAdd = v;
          else if (!addrSub) addrSub = v;
        }
      }
    }

    if (!isProbablyAddress(addrAdd) || !isProbablyAddress(addrSub)) {
      // final fallback: try the very last two object values in order
      const vals = Object.values(template).filter(v => typeof v === 'string');
      if (vals.length >= 2) {
        addrSub = addrSub || vals[vals.length - 2];
        addrAdd = addrAdd || vals[vals.length - 1];
      }
    }

    if (!isProbablyAddress(addrAdd) || !isProbablyAddress(addrSub)) {
      throw new Error('Could not find two addresses in the JSON. Expected template.address and template.SeverancePayAddress (or two address-like values).');
    }

    titleEl.textContent = `${title} (add: ${addrAdd.slice(0,10)}... sub: ${addrSub.slice(0,10)}...)`;
    msgEl.textContent = `Fetching incoming tx amounts (mock) for ${addrAdd} (add) and ${addrSub} (sub)...`;

    // For a table where each row corresponds to a single consumable, we only need one add & one sub value per row.
    const needed = numRows;

    const receivedAdd = await fetchCosmosTxs(addrAdd, needed);
    const receivedSub = await fetchCosmosTxs(addrSub, needed);

    if (receivedAdd.length < needed || receivedSub.length < needed) {
      msgEl.textContent = `Warning: received fewer txs than rows. Missing values will be treated as 0. Found add=${receivedAdd.length}, sub=${receivedSub.length}, needed=${needed}.`;
    }

    // Build data matrix mapping to columns
    // If there are 3 value columns -> [add, -sub, add-sub]
    // If 2 -> [add, -sub]
    // If 1 -> [add - sub]
    const denomLabel = template.denom || 'BABY';
    const divisor = template.divisor || 1e6; // default ubabylon -> BABY
    const dataMatrix = [];

    for (let r = 0; r < numRows; r++) {
      const add = Number(receivedAdd[r] || 0);
      const sub = Number(receivedSub[r] || 0);
      const net = add - sub;

      const rowArr = [];
      if (numValueCols === 3) {
        rowArr.push(add, sub, net);
      } else if (numValueCols === 2) {
        rowArr.push(add, sub);
      } else { // 1 or other
        rowArr.push(net);
        // if there are extra columns, pad with nulls
        for (let i = 1; i < numValueCols; i++) rowArr.push(null);
      }

      // convert to smallest-denom numeric values but keep integers (we'll format /divisor on display)
      dataMatrix.push(rowArr.map(v => (v === null ? null : Math.round(v))));
    }

    // We will pass the divisor/denom to format function via closure by temporarily overriding formatToken's default
    // but simpler: we store denomLabel & divisor and use them in buildTable by wrapping values into objects? Simpler: multiply back to "smallest unit" if template provided divisor different.
    // Our dataMatrix already uses smallest units; formatToken expects smallest units and uses divisor variable we supply.
    // We'll create a small wrapper around buildTable that binds denomLabel & divisor
    function buildWithDenom(title, columns, rows, matrix) {
  clearTable();
  if (title) titleEl.textContent = title;

  const shell = document.createElement('div');
  shell.className = 'table-shell';

  const headerStrip = document.createElement('div');
  headerStrip.className = 'table-header-strip';

  const titleSpan = document.createElement('div');
  titleSpan.className = 'title';
  titleSpan.textContent = title || 'Table';

  const metaSpan = document.createElement('div');
  metaSpan.className = 'meta';
  metaSpan.textContent = `Denom: ${denomLabel} • Values rounded to whole units`;

  headerStrip.appendChild(titleSpan);
  headerStrip.appendChild(metaSpan);
  shell.appendChild(headerStrip);

  const table = document.createElement('table');
  const thead = document.createElement('thead');
  const tbody = document.createElement('tbody');

  // header: first real column is label, so start from index 1
  const headerRow = document.createElement('tr');
  const labelTh = document.createElement('th');
  labelTh.textContent = columns[0] || '';
  headerRow.appendChild(labelTh);

  for (let i = 1; i < columns.length; i++) {
    const th = document.createElement('th');
    th.textContent = columns[i];
    headerRow.appendChild(th);
  }
  thead.appendChild(headerRow);

  rows.forEach((rowName, rIdx) => {
    const tr = document.createElement('tr');

    const first = document.createElement('td');
    first.textContent = rowName;
    tr.appendChild(first);

    const rowData = matrix[rIdx] || [];

    for (let c = 0; c < rowData.length; c++) {
      const td = document.createElement('td');
      const val = rowData[c];
      if (val === null || val === undefined) {
        td.textContent = '';
      } else {
        const span = document.createElement('span');
        span.classList.add('amount');
        if (c === 0 && rowData.length > 1) span.classList.add('positive');
        if (c === 1 && rowData.length > 1) span.classList.add('negative');
        if (c === 2) span.classList.add('net');
        span.textContent = formatToken(val, divisor);
        td.appendChild(span);
      }
      tr.appendChild(td);
    }

    tbody.appendChild(tr);
  });

  table.appendChild(thead);
  table.appendChild(tbody);
  shell.appendChild(table);
  tableWrapper.appendChild(shell);
}


    buildWithDenom(title, columns, rows, dataMatrix);

    msgEl.textContent = `Built table: used mock txs. Column mapping: ${numValueCols === 3 ? '[add, -sub, net]' : (numValueCols === 2 ? '[add, -sub]' : '[net]')}. Replace fetchCosmosTxs with real RPC to show live data.`;

  } catch (err) {
    msgEl.textContent = `Error: ${err.message || err}`;
    clearTable();
  } finally {
    btn.disabled = false;
  }
}

btn.addEventListener('click', loadAndBuild);

</script>
</body>
</html>
